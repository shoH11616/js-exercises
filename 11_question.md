### 質問事項

1. 業務ではテストコードのカバレッジ目標は何％か？
2. カバレッジ以外に重要視している指標はあるか？ある場合、具体的に何か？

### 回答

1. 一般的なカバレッジ目標は **70%～80%** が基準とされることが多い。ただし、プロジェクトやシステムの重要度に応じて調整される場合がある。
2. カバレッジ以外で重要視される指標:
   - **重要機能のテスト有無**: クリティカルな機能にテストが漏れなく含まれているか。
   - **バグ検出率**: テストを通じて事前にバグが検出できる割合。
   - **テストの実行時間**: 開発フローに負荷をかけない範囲で効率的に実行できること。
   - **レビューでのテスト品質評価**: テストコードの可読性や適切なアサーションが記載されているか。

### 質問

npmで不要なパッケージをインストールしている場合、消し忘れなどの対策はどのように行うのが一般的か？

### 回答

不要なパッケージを削除し忘れる問題への一般的な対策:

1. **`npm uninstall` を適切に利用**

   - 開発中に使わなくなったパッケージは速やかに `npm uninstall <package-name>` で削除する。
   - 開発依存なら `--save-dev` オプションを確認。

2. **`npm prune` コマンドを活用**

   - `package.json` に記載されていないパッケージを削除する。
   - 実行コマンド: `npm prune`
   - 特に依存関係の整理後や他人のプロジェクトを扱う際に有効。

3. **`npm-check` や `depcheck` を使ったチェック**

   - 不要なパッケージや使われていない依存を検出するツールを利用。
     - `npm-check`: アップデートが必要な依存関係や不要なパッケージを確認できる。
       - インストール: `npm install -g npm-check`
       - 実行: `npm-check`
     - `depcheck`: 未使用の依存関係を特定する。
       - インストール: `npm install -g depcheck`
       - 実行: `depcheck`

4. **CI/CDで自動チェック**

   - CI/CDパイプラインで、パッケージの整合性チェックを行うスクリプトを追加。
   - 例: `npm ci` を利用して正確な依存関係のインストールを確認。

5. **コードレビューでの確認**

   - 他の開発者によるレビューで、使用されていないパッケージが残っていないかを確認する。

6. **`package.json` の依存関係を定期的に見直し**

   - プロジェクトのフェーズ終了やメジャーリリース前に依存関係を確認・整理する。

7. **ドキュメントの記載**
   - 使用するライブラリやツールについてのドキュメントを更新し、不要なパッケージが記載されていれば整理する。

これらを組み合わせることで、不要なパッケージが残るリスクを最小限に抑えられる。

### 質問

Express、React、Angularはどのように使い分ければいいか？

### 回答

#### **Express**

- **特徴**: 軽量なバックエンドフレームワーク。柔軟性が高く、API構築に最適。
- **用途**: RESTful APIやシンプルなサーバー構築。

#### **React**

- **特徴**: UI構築専用のライブラリ。コンポーネントベースで仮想DOMを使用。
- **用途**: 動的でインタラクティブな単ページアプリケーション(SPA)。

#### **Angular**

- **特徴**: フルスタックフロントエンドフレームワーク。TypeScript採用で大規模開発向き。
- **用途**: 複雑なエンタープライズアプリケーションの構築。

---

### 使い分け

- **軽量なAPIサーバー**: Express
- **動的なUIのSPA**: React
- **大規模で堅牢なアプリケーション**: Angular

### 質問

ローカル・グローバルどちらにしかインストールできないパッケージは存在するか？

### 回答

基本的に、npmで提供されるパッケージはローカル・グローバルどちらでもインストール可能です。ただし、パッケージの用途によって推奨されるインストール方法が異なります。

#### **グローバルインストールが必要なパッケージ**

一部のパッケージは **CLIツール**（コマンドラインツール）として使うことを目的としており、グローバルインストールが推奨されます。

- **例**:
  - `npm`, `yarn`（パッケージマネージャ）
  - `create-react-app`（プロジェクトの初期化ツール）
  - `http-server`（ローカルサーバー構築ツール）

#### **ローカルインストールが必要なパッケージ**

ライブラリやフレームワークなどは、特定のプロジェクト内でのみ使用することを目的としており、ローカルインストールが推奨されます。

- **例**:
  - `react`, `angular`（フロントエンドライブラリ）
  - `express`（バックエンドフレームワーク）
  - `jest`, `mocha`（テストライブラリ）

#### **ローカル・グローバルどちらでも使えるパッケージ**

多くのパッケージはローカル・グローバルどちらにもインストールできますが、以下の点で使い分けます。

- **グローバル**: プロジェクトに依存せず、どこでもコマンドを使いたい場合。
- **ローカル**: 特定のプロジェクト内でのみ使用する場合。

#### **特例**

一部のパッケージはグローバルでインストールし、プロジェクト内でローカルにもインストールするケースがあります。

- 例: `eslint`（コマンドライン用にグローバルインストールし、プロジェクトごとに設定用のローカルインストールを行う）。

---

### まとめ

「どちらにしかインストールできない」パッケージはほぼ存在しませんが、用途に応じたインストール方法を選ぶことが重要です。

### 質問

devDependenciesとdependenciesの違いは？dependenciesに何を含めるべきか？

### 回答

- **dependencies**

  - 本番環境で必要なパッケージ。
  - アプリケーションの動作に直接関与するものを含める。
  - **例**:
    - フロントエンド: `react`, `vue`, `axios`
    - バックエンド: `express`, `mongoose`

- **devDependencies**
  - 開発中のみ必要なパッケージ。
  - ビルド、テスト、コード品質チェックなどに使うものを含める。
  - **例**:
    - `webpack`, `babel`, `eslint`, `jest`

### まとめ

「本番で動作に必要か」を基準に区別する。アプリが実行時に参照しないツール類はdevDependencies、それ以外はdependenciesに分類する。

### 質問

-gオプションを使ってグローバルインストールをする必要があるケースは？

### 回答

基本的に、GitHubなどで管理するプロジェクトではグローバルインストール（`-g`オプション）は避け、プロジェクト内のローカルインストールを推奨する。しかし、以下の場合はグローバルインストールが必要になることがある。

#### **グローバルインストールが必要なケース**

1. **CLIツールとしてどこでも使いたい場合**

   - ツールを複数プロジェクトで共通して使う必要がある場合。
   - **例**: `npm`, `yarn`, `eslint`, `prettier`

2. **システム全体で利用する開発支援ツール**

   - ローカルにインストールしても、PATHに追加されないと使えないもの。
   - **例**: `http-server`, `serve`, `nodemon`

3. **一時的にプロジェクトの外で使う必要がある場合**

   - 特定のディレクトリ外でコマンドを使用する場面が多い場合。
   - **例**: `create-react-app` で新しいプロジェクトを作成。

4. **CI/CDやスクリプトで利用を前提としないツール**
   - グローバル環境で一貫性が重要な場合。

---

### 注意点

- プロジェクト環境を再現するために、`-g`オプションを使うインストールは最小限にする。
- 可能であれば、`npx`を使って必要な時だけツールを実行する方法を検討する。
  - **例**: `npx eslint`（ローカルインストールでもOK）

### 結論

どうしても`-g`オプションを使わないといけないケースは、システム全体でツールを利用する必要がある場合に限られる。それ以外はローカルインストールまたは`npx`で十分対応可能。

### 質問

コードバンドルツールはどれくらい大規模なプログラムで使いたくなるものか？また、使いたくなり始める原因は何か？

### 回答

#### **コードバンドルツールを使いたくなる規模**

- **中規模以上のプロジェクト**から使用が必要になることが多い。
  - ファイル数が10～20以上に増え、モジュールが複雑化した場合。
  - 複数の依存ライブラリを使う場合。
- 単純なスクリプトや小規模なページでは不要。

---

#### **使いたくなる原因**

1. **読み込み時間の最適化**

   - モジュール数が増えると、複数のスクリプトを読み込むためリクエストが増加し、ブラウザでの読み込みが遅くなる。
   - バンドルツールで1つのファイルにまとめることでHTTPリクエストを削減できる。

2. **依存関係の管理**

   - 手動で依存関係を解決するのが困難になる。
   - バンドルツールがモジュール間の依存を自動的に解決し、正しく読み込む順序を保証する。

3. **コードの最適化**

   - バンドルツールはコードの圧縮や不要部分の削除（Tree Shaking）を自動で行い、パフォーマンスを向上させる。
   - 特に大規模なライブラリ（例: lodash, moment.js）を使う場合に有効。

4. **モジュール形式の統一**

   - ES Modules（`import/export`）やCommonJS（`require`）など、異なるモジュール形式を統一できる。
   - これにより、複数の形式をサポートする手間を削減できる。

5. **複数環境への対応**
   - 開発環境と本番環境でのコード管理を効率化できる。
   - 例: ソースマップ生成や環境ごとの最適化。

---

#### **どんなプロジェクトで必要になるか**

- 複数ページや動的コンテンツを持つアプリケーション（例: SPA）。
- React、Angular、Vueなどのフレームワークを使うプロジェクト。
- 静的サイトでも依存ライブラリが多い場合。

---

#### **結論**

コードバンドルツールは、ファイル数や依存関係が増えたことで読み込み速度や管理が困難になり始めた時に必要になる。具体的には、中規模以上のプロジェクトやフロントエンドフレームワークを使用する場合に検討するとよい。

### 質問

JavaScriptファイル以外を`import`する場合、どのような時に不具合が発生するのか？また、画像ファイルの`import`で不具合が発生した場合、webpackの設定で解決できるのか？

### 回答

#### **JavaScriptファイル以外の`import`で発生する問題**

1. **ハンドラツールへの依存**

   - JavaScript以外のファイル（画像、CSS、フォントなど）を`import`すると、ブラウザはそのまま解釈できないため、webpackやViteのようなバンドラツールが必要。
   - これにより、ツールの設定が不完全だとエラーが発生する可能性がある。

2. **設定ミスによるエラー**

   - バンドルツールが対応していない形式（例: Webpackの`file-loader`や`url-loader`が設定されていない場合）では、`import`が失敗する。
   - ファイルパスの解決や形式の変換が正しく行われず、ランタイムエラーやビルドエラーになる。

3. **環境ごとの挙動の違い**
   - 開発環境では正しく動作しても、本番環境では設定の違いにより動作しないケースがある（例: 相対パスの誤解釈、ファイルが見つからないなど）。

---

#### **具体例: 画像ファイルの`import`**

- **現象**
  - `import logo from './logo.png';` のように画像を`import`した場合、Webpackなどが正しく設定されていないと画像パスが解決されない。
- **原因**
  - 画像を処理するローダー（例: `file-loader`, `url-loader`, またはWebpack5の`asset`モジュール）が設定されていない。
- **解決方法**
  1. **Webpackの設定を追加**
     ```javascript
     module.exports = {
       module: {
         rules: [
           {
             test: /\.(png|jpg|jpeg|gif|svg)$/i,
             type: "asset/resource", // または file-loader/url-loader
           },
         ],
       },
     };
     ```
  2. **バンドルツールを適切に設定**
     - ViteやParcelを使う場合、デフォルトで画像`import`がサポートされていることが多いが、確認が必要。

---

#### **他の例: CSSやフォントファイル**

- CSSを`import`する場合: `css-loader`が必要。
- フォントを`import`する場合: `file-loader`または`url-loader`が必要。

---

#### **結論**

JavaScript以外のファイルを`import`する場合、不具合の原因は主にバンドルツールの設定不足。Webpackの設定を適切に調整することで解決可能。また、他のバンドラ（Vite、Parcel）ではデフォルト対応しているケースが多いため、プロジェクトに適したツールを選ぶことが重要。

### 質問

ホットモジュール交換（HMR）モードでは、キャッシュは影響しないのか？影響する場合、どのように回避しているのか？

### 回答

#### **キャッシュの影響**

- HMRモードでは、バンドルが生成されるたびに変更部分がブラウザに反映されるが、**キャッシュの影響を受けないように設計**されている。
- HMRは通常、以下の仕組みを利用してキャッシュの問題を回避する。

---

#### **キャッシュ回避の手段**

1. **ユニークなハッシュ付きURL**

   - WebpackやViteでは、変更が発生したファイルに対してユニークなハッシュ（例: `main.js?hash=12345`）を付与。
   - これによりブラウザが新しいリソースを認識し、キャッシュが無効化される。

2. **HMR用のWebSocket通信**

   - HMRはWebSocketを利用してサーバーとブラウザ間で通信。
   - サーバーが変更を検知すると、ブラウザに通知して該当部分を再取得し、動的に更新。
   - キャッシュが効くHTTPリクエストを使用しないため、キャッシュの影響を受けない。

3. **ライブリロードや再リクエスト**

   - ファイルが更新されると、ブラウザが特定のスクリプトやスタイルを再リクエストする。
   - キャッシュを避けるために`Cache-Control: no-cache`や`pragma`ヘッダーが自動的に付与される場合もある。

4. **Source Mapの更新**
   - HMRでは、変更部分だけを再読み込みする際に最新のSource Mapを取得。
   - キャッシュされた古いデバッグ情報を参照しない。

---

#### **HMRでキャッシュ回避が不足する場合**

- ローカル開発ではHMRで十分だが、設定が不十分な場合、ブラウザが古いキャッシュを利用することもある。
- その場合の対策:
  - **強制キャッシュバスティング**:
    - Webpackの設定で`output.filename`にハッシュを含める。
      ```javascript
      output: {
        filename: '[name].[contenthash].js',
      },
      ```
  - **`Cache-Control`ヘッダーの設定**:
    - ローカルサーバーで`no-store`や`no-cache`を設定してキャッシュを完全に無効化。

---

#### **結論**

HMRモードは、ハッシュ付きURLやWebSocket通信を活用してキャッシュの影響を最小限に抑える設計になっている。まれにキャッシュの問題が発生する場合は、ファイル名にハッシュを付ける設定やHTTPヘッダーでのキャッシュ無効化が有効。

### 質問

Babelを使っているプロジェクトでは、常に最新の機能を使いたい場合、どのようなバージョン管理をしているか？

### 回答

Babelを使うプロジェクトでのバージョン管理方法:

1. **Babelのバージョンを固定**

   - `package.json`の`devDependencies`でBabelのバージョンを固定し、一貫性を保つ。
   - 例: `"@babel/core": "7.21.0"`
   - チーム全体で同じバージョンを使用することで、ビルドやテストの結果が一致。

2. **必要に応じてアップデート**

   - 新しい言語機能が必要になった時や、重要なバグ修正があった場合にBabelをアップデート。
   - アップデート前にローカルでテストを行い、問題がないか確認。

3. **バージョン範囲の指定**

   - `^`や`~`を使って互換性のあるバージョンを自動的に取り込む。
   - 例: `"@babel/core": "^7.21.0"`
   - パッチやマイナーアップデートを自動で適用しつつ、メジャーアップデートは手動で管理。

4. **新機能のためのプラグイン追加**

   - 必要な新機能だけを個別のBabelプラグインで導入し、Babel自体のアップデートを最小限に。
   - 例: `@babel/plugin-proposal-optional-chaining`

5. **定期的なバージョン見直し**

   - 定期的にBabelとそのプラグインの最新バージョンをチェックし、必要なら更新。
   - 更新時にはテストとコードレビューを徹底。

6. **CI/CDパイプラインでの管理**
   - CI/CD環境でもローカルと同じBabelバージョンを使用し、一貫性を維持。

### まとめ

常に最新のBabelを使うより、プロジェクトの安定性と開発効率を考慮しつつ、必要に応じてアップデートする方法が一般的。バージョン管理を適切に行い、新機能の導入時にはテストと検証を怠らないことが重要。

### 質問

JSXを使った場合、Babelのようなトランスコンパイラは必須か？また、Babel以外に選択肢はあるか？

### 回答

#### **JSXにトランスコンパイラは必須か？**

- **必須**。
  - JSXはブラウザが直接解釈できないため、トランスコンパイルが必要。
  - JSXは通常、Reactの`createElement`関数に変換される形でJavaScriptコードに変換される。

---

#### **Babel以外の選択肢**

1. **TypeScript**

   - TypeScriptはJSXを直接サポートしており、トランスコンパイル可能。
   - 設定例: `tsconfig.json` で`"jsx": "react-jsx"`または`"react"`を指定。
   - **特徴**: 型チェックが付与されるため、型安全性も向上。

2. **esbuild**

   - 高速なバンドラ兼トランスパイラで、JSXの変換をサポート。
   - **特徴**: パフォーマンス重視で、特に開発時のビルド速度が非常に速い。

3. **SWC**

   - Rustで書かれた次世代トランスパイラで、Babelの代替として注目。
   - JSXトランスパイルをサポートし、パフォーマンスが非常に高い。
   - **特徴**: 特に大規模プロジェクトやCI/CDでのビルドに向いている。

4. **Vite**

   - 近年人気のビルドツールで、JSXをサポート。
   - 内部で`esbuild`を利用し、高速なトランスパイルを提供。
   - **特徴**: 開発用サーバーやホットリロードが組み込まれている。

5. **Parcel**
   - ゼロ設定で動作するバンドラ。JSXの変換を自動的に行う。
   - **特徴**: 設定不要で簡単に使える。

---

#### **まとめ**

JSXを使う場合、Babelのようなトランスコンパイラが必要。ただし、Babel以外にも`TypeScript`や`esbuild`、`SWC`などの選択肢がある。プロジェクトの規模や要件に応じて、最適なツールを選ぶのがベスト。

### 質問

JSXのようなUIとロジックを統合した開発手法は、従来の分離型手法におけるどのような課題を解決しているか？また、統合型のメリットは何か？

---

### **従来の分離型手法の課題**

1. **コードの断片化**

   - UI（HTML/CSS）とロジック（JavaScript）が別ファイルに分かれるため、機能の関連性を追いにくい。
   - 同じ機能を変更する際に複数ファイルを編集する必要があり、ミスが発生しやすい。

2. **状態管理の複雑化**

   - UIとロジックが分離されていると、コンポーネントの状態やイベント処理が複雑になりやすい。
   - 例: DOMを手動で操作し、状態を同期する必要がある。

3. **再利用性の低さ**

   - UIとロジックが分離している場合、同じUIパターンを別の場所で使い回すのが難しい。

4. **デバッグの難しさ**
   - UIとロジックが分かれているため、エラーの原因特定が難しく、開発効率が低下。

---

### **UIとロジックを統合する手法の解決策**

1. **コンポーネントベースの設計**

   - UIとロジックが1つのコンポーネントにまとめられるため、コードの見通しが良くなる。
   - 必要な変更がコンポーネント単位で完結する。

2. **状態管理の簡略化**

   - ロジックとUIが統合されているため、状態（state）と表示が同期しやすい。
   - JSXでは`useState`や`props`で明確に状態を管理。

3. **高い再利用性**

   - 独立したコンポーネントとして設計するため、UIとロジックをセットで他の場所に簡単に再利用可能。

4. **直感的なデバッグ**
   - UIとロジックが統合されているため、変更箇所が特定しやすく、デバッグ効率が向上。

---

### **統合型のメリット**

1. **シンプルで一貫性のあるコード**

   - UIとロジックが1つのファイルやコンポーネントにまとまることで、コードが簡潔になり管理しやすい。

2. **効率的な開発フロー**

   - コードベースが統一されることで、機能追加や変更が迅速に行える。

3. **リアクティブな開発**

   - JSXのように、状態に応じてUIが自動更新される仕組みが組み込まれている。

4. **拡張性**

   - コンポーネント単位でロジックとUIがまとまっているため、新しい機能やデザイン変更に柔軟に対応可能。

5. **チーム間の連携が向上**
   - コンポーネント単位でタスクを分割しやすく、担当の切り分けが明確。

---

### **注意点**

- 初学者には複雑に感じられる場合がある（JSXの文法や状態管理の理解が必要）。
- 大規模なプロジェクトではコンポーネントの整理と管理が重要。

### **結論**

UIとロジックを統合する手法は、分離型の課題であるコードの断片化や状態管理の複雑さを解決し、再利用性や開発効率を大幅に向上させる。ただし、プロジェクト規模やチームのスキルセットに応じた適切な設計が求められる。

### 質問

JSXはReact以外で使われているフレームワークがあるか？

### 回答

JSXはReactと密接に関連していますが、React以外のフレームワークやライブラリでも利用されています。

---

#### **React以外でJSXが使われている主なフレームワークやライブラリ**

1. **Preact**

   - Reactの軽量版（同様のAPIを提供）。
   - JSXを利用可能で、Reactとほぼ同じ感覚で書ける。
   - **用途**: パフォーマンスが重要な軽量アプリケーション。

2. **Vue.js**

   - 通常はテンプレート構文を使用するが、JSXをサポート。
   - プラグインや設定（`babel-plugin-transform-vue-jsx`）を追加することでJSXを利用可能。
   - **用途**: JSXの利便性とVueの強力なデータバインディングを組み合わせたい場合。

3. **SolidJS**

   - 高速でリアクティブなフレームワーク。
   - JSXを採用しており、Reactと似た開発スタイルを提供。
   - **用途**: 高性能なリアクティブUIを構築するプロジェクト。

4. **Svelte（部分的に）**

   - 通常は独自のテンプレート構文を使用するが、特定のプラグインや設定を利用してJSXのサポートを追加可能。
   - **用途**: Svelte環境でのJavaScript統一を重視する場合。

5. **Stencil**

   - Web Componentsを構築するためのフレームワーク。
   - JSXをサポートしており、直感的にコンポーネントを記述可能。
   - **用途**: カスタム要素を使った再利用可能なUI構築。

6. **Dojo Framework**
   - モダンなWebアプリケーション向けに設計されたフレームワーク。
   - JSXでウィジェット（コンポーネント）を記述可能。
   - **用途**: エンタープライズ向けの堅牢なアプリケーション。

---

#### **JSXが選ばれる理由**

- HTMLライクな構文で直感的にUIツリーを記述できる。
- JavaScript内にUIを直接記述することで、状態管理やイベント処理と統合しやすい。
- トランスパイラ（Babelなど）を使えば柔軟に他のフレームワークに適応可能。

---

### 結論

JSXはReact以外にもPreact、Vue.js、SolidJS、Stencilなど、複数のフレームワークで利用可能。特にReact互換やリアクティブなUIを必要とするプロジェクトで有効に活用されている。

### 質問

JSXはReact専用の記法と理解してよいか？

### 回答

JSXはReactに密接に関連して設計されていますが、**React専用の記法ではありません**。以下のポイントを押さえておくとよいです。

---

#### **JSXの本質**

- **JavaScriptの構文拡張**:

  - JSXはJavaScriptの構文拡張であり、HTMLライクな記法でUIツリーを記述するもの。
  - トランスパイラ（例: Babel）がJSXをJavaScriptコード（例: `React.createElement`）に変換。

- **Reactとの関係**:
  - ReactはJSXを標準でサポートしており、最適化されている。
  - JSXを使うと、Reactコンポーネントの記述が簡潔かつ直感的になる。
  - ただし、JSXそのものはReactに依存していない。

---

#### **React以外での利用**

- **他のフレームワークでも利用可能**:

  - Preprocessing（例: Babel）を通じて、React以外のフレームワークでもJSXを利用可能。
  - 例: Preact、SolidJS、Vue.js（特定設定下）など。

- **カスタムレンダラーの利用**:
  - JSXはトランスパイル結果がフレームワークに依存しないため、`createElement`のような関数を用意すれば独自のフレームワークでも使える。

---

#### **Reactを使う場合のJSXの位置付け**

- 実質的に**React開発での標準記法**:
  - ReactはJSXを中心に設計されており、JSXの利用が推奨されている。
  - JSXなしでもReactは利用可能だが、HTMLライクな記法の恩恵を受けられなくなる。

---

### 結論

JSXはReact専用ではないが、Reactの開発において事実上の標準記法として機能している。他のフレームワークでも利用可能だが、設定やトランスパイラが必要になることが多い。

### 質問

アロー関数に型アノテーションをつけるのは避けたほうがいいのか？

### 回答

#### **型アノテーションをつけるべき場合**

- 型推論が効かない場合。
- 他の開発者に意図を明確に伝えたい場合。

**例:**

```typescript
const add = (a: number, b: number): number => a + b;
```

#### **型アノテーションを避けるべき場合**

TypeScriptの型推論が正確に動作する場合。
冗長になり、簡潔さが損なわれる場合。
例（推論が有効な場合）:

```typescript
コードをコピーする
const add = (a: number, b: number) => a + b; // 戻り値は自動推論される
結論
必要な場合だけ型アノテーションをつける。推論が十分なら省略してもOK。
```

### 質問

この本の次に読むのにおすすめのJavaScript・TypeScriptの本は？

### 回答

#### **JavaScriptのおすすめ本**

1. **「JavaScript: The Good Parts」**

   - 著者: Douglas Crockford
   - JavaScriptの本質を深く理解できる名著。やや古いが、JavaScriptの基本概念を体系的に学べる。

2. **「You Don’t Know JS (Yet)」シリーズ**

   - 著者: Kyle Simpson
   - JavaScriptの仕組みを詳細に解説。初心者～中級者向けに全6冊で構成。

3. **「Effective JavaScript」**

   - 著者: David Herman
   - 高品質なJavaScriptコードを書くための59のベストプラクティスを学べる。

4. **「JavaScript Patterns」**
   - 著者: Stoyan Stefanov
   - JavaScriptの設計パターンや効率的なコードを書くためのヒントを解説。

---

#### **TypeScriptのおすすめ本**

1. **「Programming TypeScript」**

   - 著者: Boris Cherny
   - TypeScriptの基本から応用までを幅広く学べる一冊。型安全なプログラミングの重要性を実感できる。

2. **「Effective TypeScript」**

   - 著者: Dan Vanderkam
   - TypeScriptでの開発効率を向上させるための62のベストプラクティスを解説。

3. **「TypeScript Quickly」**

   - 著者: Yakov Fain, Anton Moiseev
   - TypeScriptの実践的な入門書。TypeScriptを使ったプロジェクト開発に役立つ。

4. **「Learning TypeScript」**
   - 著者: Josh Goldberg
   - TypeScript初心者向けの入門書。基本から応用まで幅広く学べる。

---

#### **結論**

- **JavaScriptを深めたい場合**: 「You Don’t Know JS (Yet)」シリーズ
- **TypeScriptに移行したい場合**: 「Programming TypeScript」または「Effective TypeScript」  
  どちらも実務に直結する知識が得られる本としておすすめ。
