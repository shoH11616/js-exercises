1. 「部分的に使用済みのイテレータ」とはどういう意味でしょうか？
   ・let iter = listSymbol.iterator;という行で配列listのイテレータを作成。この時点でイテレータiterはまだ使用されていない。
   ・let head = iter.next().value;でイテレータから最初の要素が取り出される。この操作ではまだ2,3,4,5は取り出されていない。つまり「部分的に使用済み」の状態になっている。

2. 「利便性のためにイテレータ自体を反復可能にしておく」とありますが、利便性の1つとして先ほどの「部分的に使用済み」のイテレータを使って反復処理を行いたい時があると思いますが他に利便的なケースがありますか？
   ・複数の反復処理：イテレータが反復可能であると、同じイテレータを複数の安福処理で再利用することができ、データの再取得や再計算を割けることに繋がる
   ・遅延評価：イテレータは「遅延評価」を可能にする、つまりデータが実際に必要になるまでその生成や取得を遅らせることができ、大量のデータを扱う場合やデータの生成に時間が掛かる場合に便利。

3. next().doneの値はどのように決められているのでしょうか？next()が一度呼ばれた時点で次のnext()まで実行されているのでしょうか？
   ・ジェネレータ関数は、next()メソッドを呼び出すために実行が進みyieldキーワードで指定された値を返す。そしてその実行状態は保存され、次にnext()が呼ばれたときに前回停止した箇所から再開する。
   ・next.doneの値はジェネレータ関数が終了したかどうかを示す。具体的には、ジェネレータ関数内でこれ以上yieldする値がない場合、next.doneはtrueを返す
   ・したがってnextが一度呼ばれた時点で次のnextまで実行されるわけではない。呼び出されるためにジェネレータ関数の実行を一歩進め、その時点でのyieldの値を返し、その後の実行は停止する。

4. ここで挙げられている方法以外で、ユーザーがタスク(マイクロタスクでない)を作る方法はありますか。
   ・Promise, async/await, setTimeout/setInterval, Fetch APIなど
   ・非同期イベント駆動アーキテクチャを実装するためのEventEmitter, メインスレッドとは別のスレッドでスクリプトを実行するためのAPIであるWeb Workersなどがある

5. Promiseがマイクロタスクキューに積まれるのは、Promiseがコード中で評価されるタイミングということでよろしいでしょうか。
   ・この認識で合ってそう。Promisega評価される時、つまり新しいPromiseが作成されたときや既存のPromiseがresolveまたはrejectされたときに、そのPromiseのthenやcatchメソッドに登録されたコールバック関数がマイクロタスクキューに追加される。

6. Promise型は全て非同期である(非同期が使用されている)という認知で大丈夫でしょうか？
   ・Promiseは非同期操作を表現するためのオブジェクト。非同期操作の結果を扱うための便利なメカニズムを提供するが、それ自体が常に非同期であるわけではない。
   ・Promisehaその内部の処理が同期的にも非同期的にも実行できる。Promiseのコンストラクタ関数内で行われる処理は同期的に実行される。
   ・Promiseが作成されるときそのconstructor関数内の処理はすぐに実行される。しかしながら、thenやcatchメソッドに登録されたコールバック関数は非同期的に実行される。

7. // Promiseが解決したら、ステータスとヘッダが利用できる。とありますがこれはPromiseが満たされたらの間違いでは？
   ・Promiseが解決するという表現は、Promiseが満たされるまたは成功することを意味する。したがって「Promiseは解決したら、ステータスとヘッダが利用できる」という文章は
   「Promiseが満たされた（つまり、非同期操作が成功した）ときに、HTTPのステータスとヘッダが利用できるようになる」という意味になる。

8. 'finally'ブロック内での後処理でエラーがでた場合を想定すると、さらに次にcatchブロックを追加することもありますか？
   ・finallyブロック内でエラーが発生した場合、そのエラーはfinallyが返すPromiseによって拒否される。
   ・したがって、finallyブロックの後にcatchブロックを追加して、そのエラーを処理することが可能。

9. エラーを発生させたthen()内でエラー時の処理を完結させた方が良いのでは？と思ったのですが、あとに続くthen()でエラーを解析できると嬉しい場面があるのでしょうか？
   ・then()の第2引数にエラーハンドラを渡す方法よりも、catchメソッドを使用したほうがいい場合がある
   ・なぜなら、catchメソッドを使用すると、Promiseチェーン全体のエラーを一か所で処理ができるから。これによりコードの可読性と保守性を向上することができる。

10.
