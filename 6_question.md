1. 「部分的に使用済みのイテレータ」とはどういう意味でしょうか？
   ・let iter = listSymbol.iterator;という行で配列listのイテレータを作成。この時点でイテレータiterはまだ使用されていない。
   ・let head = iter.next().value;でイテレータから最初の要素が取り出される。この操作ではまだ2,3,4,5は取り出されていない。つまり「部分的に使用済み」の状態になっている。

2. 「利便性のためにイテレータ自体を反復可能にしておく」とありますが、利便性の1つとして先ほどの「部分的に使用済み」のイテレータを使って反復処理を行いたい時があると思いますが他に利便的なケースがありますか？
   ・複数の反復処理：イテレータが反復可能であると、同じイテレータを複数の安福処理で再利用することができ、データの再取得や再計算を割けることに繋がる
   ・遅延評価：イテレータは「遅延評価」を可能にする、つまりデータが実際に必要になるまでその生成や取得を遅らせることができ、大量のデータを扱う場合やデータの生成に時間が掛かる場合に便利。

3. next().doneの値はどのように決められているのでしょうか？next()が一度呼ばれた時点で次のnext()まで実行されているのでしょうか？
   ・ジェネレータ関数は、next()メソッドを呼び出すために実行が進みyieldキーワードで指定された値を返す。そしてその実行状態は保存され、次にnext()が呼ばれたときに前回停止した箇所から再開する。
   ・next.doneの値はジェネレータ関数が終了したかどうかを示す。具体的には、ジェネレータ関数内でこれ以上yieldする値がない場合、next.doneはtrueを返す
   ・したがってnextが一度呼ばれた時点で次のnextまで実行されるわけではない。呼び出されるためにジェネレータ関数の実行を一歩進め、その時点でのyieldの値を返し、その後の実行は停止する。

4. ここで挙げられている方法以外で、ユーザーがタスク(マイクロタスクでない)を作る方法はありますか。
   ・Promise, async/await, setTimeout/setInterval, Fetch APIなど
   ・非同期イベント駆動アーキテクチャを実装するためのEventEmitter, メインスレッドとは別のスレッドでスクリプトを実行するためのAPIであるWeb Workersなどがある

5. Promiseがマイクロタスクキューに積まれるのは、Promiseがコード中で評価されるタイミングということでよろしいでしょうか。
   ・この認識で合ってそう。Promisega評価される時、つまり新しいPromiseが作成されたときや既存のPromiseがresolveまたはrejectされたときに、そのPromiseのthenやcatchメソッドに登録されたコールバック関数がマイクロタスクキューに追加される。

6. Promise型は全て非同期である(非同期が使用されている)という認知で大丈夫でしょうか？
   ・Promiseは非同期操作を表現するためのオブジェクト。非同期操作の結果を扱うための便利なメカニズムを提供するが、それ自体が常に非同期であるわけではない。
   ・Promisehaその内部の処理が同期的にも非同期的にも実行できる。Promiseのコンストラクタ関数内で行われる処理は同期的に実行される。
   ・Promiseが作成されるときそのconstructor関数内の処理はすぐに実行される。しかしながら、thenやcatchメソッドに登録されたコールバック関数は非同期的に実行される。

7. // Promiseが解決したら、ステータスとヘッダが利用できる。とありますがこれはPromiseが満たされたらの間違いでは？
   ・Promiseが解決するという表現は、Promiseが満たされるまたは成功することを意味する。したがって「Promiseは解決したら、ステータスとヘッダが利用できる」という文章は
   「Promiseが満たされた（つまり、非同期操作が成功した）ときに、HTTPのステータスとヘッダが利用できるようになる」という意味になる。

8. 'finally'ブロック内での後処理でエラーがでた場合を想定すると、さらに次にcatchブロックを追加することもありますか？
   ・finallyブロック内でエラーが発生した場合、そのエラーはfinallyが返すPromiseによって拒否される。
   ・したがって、finallyブロックの後にcatchブロックを追加して、そのエラーを処理することが可能。

9. エラーを発生させたthen()内でエラー時の処理を完結させた方が良いのでは？と思ったのですが、あとに続くthen()でエラーを解析できると嬉しい場面があるのでしょうか？
   ・then()の第2引数にエラーハンドラを渡す方法よりも、catchメソッドを使用したほうがいい場合がある
   ・なぜなら、catchメソッドを使用すると、Promiseチェーン全体のエラーを一か所で処理ができるから。これによりコードの可読性と保守性を向上することができる。

10. 課題で"Web API の呼び出しを並行に実行すると、数次第で何らかのエラーに"とありましたが、API呼び出しは並行に呼び出したいケースが多いと思いました。業務などで実装する場合はエラーが起きないように何か別の方法を使ったりメジャーな回避策があったりするのでしょうか？
    ・APIの呼び出し回数を一定の時間内に制限するレートリミッティング
    ・エラーが発生した場合に自動的にリクエストを再試行するリトライロジック
    ・リクエストをキューにいれて順番に処理するキューイングなどで一度に処理されるリクエスト数を制御し、サーバー負荷を軽減させる。

11. ドミノ倒しのようなPromiseチェーンを作るのではなく、マトリョーシカ人形のように、あるPromiseの中に別のPromiseが入れ子になっているような一連のPromiseを作成する。とありますが、いまいちイメージがつきません。
    ・ドミノ倒しのようなPromiseはthenの中にreturn Promise.resolve()にいれていく。各タスクが順番に実行され一つのタスクが完了すると次のタスクが開始されていくため、ドミノが一つずつ倒れていく様子に似ている。マトリョーシカはわからん。

12. async関数ではなく明示的にnew Promiseを返す必要があるのは、resolveまたはrejectをインスタンスのプロパティとして保持するケース以外にありますか？
    ・async/awaitだけでは実現できない、タイムアウトの実装やイベント駆動型の非同期処理はnewPromiseで書く必要がある。

13. await式が完了するまで、次の行には進みません。ブロックしていない、というのはどのような意図でしょうか。
    ・ブロックしていない＝awaitがプログラム全体を停止させるわけではなく、特定の非同期関数の中でのみ実行を一時停止するという意味で使われている。
    ・これにより、JavaScriptは他のタスクを実行しながら非同期処理を待つことができ、効率的な非同期プログラミングが可能になる。

14. 「awaitを使うコードは、そのコード自身も非同期になる」について、何が非同期になっているのかがわからないです。
    ・同期非同期が処理を待つか待たないかという点は正しい。
    ・awaitを使うと、そのコード自身が非同期になることは、awaitが使われる関数は非同期関数（async関数）である必要があり、その関数自体がPromiseを返すという意味。つまりその実行は非同期になる。
    console.log('Before async function');
    asyncFunction();
    console.log('After async function');
    ⇒asyncFunction();にawaitがあれば、その官僚を待たずにAfter～が実行される。非同期処理を同期的に書くことができ、関数自体は非同期になる。
